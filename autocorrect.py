# -*- coding: utf-8 -*-
"""autocomplete.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15nory2OiHSgRzAxwo5uHRCNgAc5HEkoH
"""


from shutil import register_unpack_format
from fast_autocomplete.misc import read_csv_gen
from fast_autocomplete import AutoComplete
from typing import List, Dict
import cyrtranslit
import string as s
import pickle
import tqdm
import csv
import re

from nlp import cleaning
from autocomplete import AutoCompleter


class LayoutCorrector:
    def __init__(self):
        self.rus = "§1234567890-=qwertyuiop[]asdfghjkl;'\`zxcvbnm,./ "
        self.eng = ">1234567890-=йцукенгшщзхъфывапролджэё]ячсмитьбю/ "
        self.ru2en_dict = dict(zip(self.eng, self.rus))
        self.en2ru_dict = dict(zip(self.rus, self.eng))

    def en2ru(self, string) -> str:
        return "".join([self.en2ru_dict[a] for a in string.lower()])
    
    def ru2en(self, string) -> str:
        return "".join([self.ru2en_dict[a] for a in string.lower()])

    def isEnglish(self, string) -> bool:
        count = 0
        for x in string:
            if x in self.eng:
                count += 1
        if len(string) * 0.5 < count:
            return False
        return True


class AutoCorrector:
    def __init__(
        self, 
        path2words : str,
        path2csv : str = None, 
        trainColumnName = "Название СТЕ", 
    ) -> None:
        self.special_symbols = s.ascii_uppercase + "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ1234567890-"
        self.symbols = self.getValidSymbols()
        self.trainColumnName = trainColumnName
        self.words  = self.load_words(path2words)
        if path2csv:
            self.words = self.getWords(path2csv)
        self.autoComplete = self.getAutoComplete(self.words, self.symbols)
        self.corrector = LayoutCorrector()

    def load_words(self, path2words):
        return pickle.load(open(path2words, 'rb'))

    def save_words(self, path2words):
        picklefile = open(path2words, 'wb')
    
        #pickle the dictionary and write it to file
        pickle.dump(completer.words, picklefile)
        #close the file
        picklefile.close()

    def getValidSymbols(self):
        return s.ascii_lowercase + "абвгдеёжзийклмнопрстуфхцчшщъыьэюя" + "1234567890"

    def isSerial(self,
                 input_string: str,
                 threshold=0.5) -> bool:
        counter = 0
        for x in input_string:
            if x in self.special_symbols:
                counter += 1

        return counter / len(input_string) > threshold


    def getWords(self, path : str) -> Dict[str, dict]:
        csv_gen = read_csv_gen(path, csv_func=csv.DictReader)
        words = {}

        for line in tqdm.tqdm(csv_gen, 
                                       desc = "processing dataset"):
            processed_string = cleaning(line[self.trainColumnName])
            local_words = processed_string.split(" ")
            for index in range(len(local_words)):
                first = local_words[index]
                if first: 
                    words[first.strip()] = {}
        return words
    
    def toLatin(self, string) -> str:
        return cyrtranslit.to_latin(string, 'ru')
    
    def toRussian(self, string) -> str:
        return cyrtranslit.to_cyrillic(string, 'ru')

    def getAutoComplete(self, words, symbols):
        return AutoComplete(
            words=words,
            valid_chars_for_string= symbols
            )
    
    def request(self, query, size = 1, max_cost = 2):
        outputs = self.autoComplete.search(
            word=cleaning(query),
            size = size, 
            max_cost = max_cost
            )
        return [item[0] + " " for item in outputs]

    def search(self, query_sentence: str) -> List[str]:
        output_sentence = []
        for query in query_sentence.split(" "):
            if self.isSerial(query):
                output_sentence += query
                continue

            output = self.request(query)

            if len(output):
                output_sentence += output
                # return output
                continue
            else:
                #  проверяем преимущественно ли количество английского текста
                if self.corrector.isEnglish(query):
                    # проверяем найдены ли совпадения при переводе на русскую раскладку
                    output = self.request(self.corrector.en2ru(query))
                    if len(output):
                        output_sentence += output
                        continue
                        # return output

                    # проверяем найдены ли совпадения при переводе на русскую траскрипцию
                    output = self.request(self.toRussian(query))
                    if output:
                        output_sentence += output
                        # return output
                        continue
                else:

                    # проверяем найдены ли совпадения при переводе на русскую раскладку
                    output = self.request(self.corrector.ru2en(query))
                    if len(output):
                        output_sentence += output
                        continue
                        # return output

                    # проверяем найдены ли совпадения при переводе на русскую раскладку
                    output = self.request(self.toLatin(query))
                    if output:
                        output_sentence += output
                        continue
                        # return output
        if output_sentence:
            return "".join(output_sentence)
        return ""



    def __call__(self, query : str) -> List[str]:
        return self.search(query)


if __name__ == "__main__":
    completer = AutoCompleter('file.pkl')
  
    while True:
        print(completer(input("search: ")))
